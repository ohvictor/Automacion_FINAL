%% 1 - CREACION DEL ROBOT

clear variables
clc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Dimensiones del brazo:                               %
%Estas variables definen las dimensiones del          % 
%brazo robótico en términos de la distancia entre las %
%articulaciones. Los valores de 𝑥 e 𝑦 representan la  %
%proyección de la distancia en el eje 𝑋 (horizontal)  %
%y en el eje Y (vertical).%                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Distancias de Z1 a Z2

x1 = 50;    % Longitud del codo - Distancia en X
y1 = 144;   % Altura en la imagen - Distancia en Y

%Distancias de Z2 a Z3

x2 = 144;   % Longitud del brazo 2 - Distancia en X
y2 = 0;

%Distancias de Z3 a Z4 siendo Z4 el EE

x3 = 144;   % Longitud del brazo 3 - Distancia en X
y3 = 0;

%Distancias entre links

xy1 = sqrt(y1^2+x1^2); %Distancia MOD entre Z1 y Z2
xy2 = sqrt(y2^2+x2^2); %Distancia MOD entre Z2 y Z3
xy3 = sqrt(y3^2+x3^2); %Distancia MOD entre Z3 y Z4

% Límites de giro de los joints

offset_codo = atan2(y1,x1);             %angulo de inclinación del primer segmento (𝑍1 a 𝑍2)
qlim2 = [-pi/2 pi/2] - offset_codo;     %limite rotacion z2
qlim3 = [-pi/2 pi/2] + offset_codo;     %limite rotacion z3

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Tolerancia:                                          %
%Las dimensiones de cada link podrian variar hasta un %
%5 %. Esta variacion aplica a todos los links         % 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

tol = 0.00;
y1 = y1*(1+tol);   
x1 = x1*(1+tol);    
y2 = 0;
x2 = x2*(1+tol);   
y3 = 0;
x3 = x3*(1+tol);   
xy1 = sqrt(y1^2+x1^2);
xy2 = sqrt(y2^2+x2^2); 
xy3 = sqrt(y3^2+x3^2); 

% Construcción de Links
%Usamos la convención de Denavit-Hartenberg modificada (MDH).

L(1) = RevoluteMDH('d',0,'a',0,'alpha',0);
L(2) = RevoluteMDH('d',0,'a',0,'alpha',-pi/2,'qlim', qlim2);
L(3) = RevoluteMDH('d',0,'a',xy1,'alpha',0,'qlim', qlim3);
L(4) = RevoluteMDH('d',0,'a',xy2,'alpha',0);
L(5) = RevoluteMDH('d',xy3,'a',0,'alpha',pi/2);

%Tool: Define la posición del efector final a 100 mm de distancia en el eje Z usando la función transl, que crea una matriz de transformación para la posición de la herramienta.
%qz: Define una configuración inicial para las articulaciones del robot, donde: 
%0: Articulación L(1) en posición neutral.
%-offset_codo: Compensa la inclinación inicial de  L(2).
%offset_codo: Compensa la inclinación inicial de L(3).
%pi/2: Posición del cuarto link.
%0: Articulación L(5) (sin rotación adicional).

Tool = transl([0 0 100]);
qz = [0 -offset_codo offset_codo pi/2 0];

% Construcción del robot

robot = SerialLink(L,'tool', Tool);
robot.name = "WidowX Mark II";

%2.2 - DIBUJO TRAYECTORIA

x0= 350; y0=150; z0=0; width=150;large=200; %Mesa de dibujo
xmin = x0 - width/2; xmax = x0 + width/2; %

ymin = y0 - large/2;
ymax = y0 + large/2

drawTablePaper(width, large, x0, y0, z0);
robot.teach(qz);

% Define the number of steps for smooth movement
steps = 30;

% Center of the rectangle (same as used in drawTablePaper)
rect_center = [x0, y0, z0]; % Center coordinates (x0, y0, z0)

paintHeight = 75;
limits = [
    -pi, pi;                                    % q1: Rotación completa de la base
    -pi/2 - offset_codo, pi/2 - offset_codo;    % q2: Ajustado por el offset del codo
    -pi/2 + offset_codo, pi/2 + offset_codo;    % q3: Ajustado por el offset del codo
    -pi/2, pi/2;                                % q4: Rotación de ±90°
    -pi, pi                                     % q5: Rotación completa del efector final
];

% Obtiene la posición inicial en el espacio cartesiano a partir de qz
currentPos = getPositionFromQz(robot, qz)'
%finalPos = [xmin, currentPos(2) , z0 + paintHeight];
steps = 30;

% Rotación constante (ejemplo de matriz de rotación)
%rotation = eye(3); % Rotación identidad, sin rotación adicional

theta = pi/2; 
rotation = [1,0,0; 
           0,0,-1; 
           0,1,0];
finalPos = [xmax, currentPos(2) , z0 + paintHeight];
[currentPos, Ts, qz] = moveRobotArm(robot, qz, finalPos, steps, rotation);
pause(2); % Pauses execution for 2 seconds

finalPos = [currentPos(1), currentPos(2) + 10 , currentPos(3)];
[currentPos, Ts, qz] = moveRobotArm(robot, qz, finalPos, steps, rotation);
pause(2); % Pauses execution for 2 seconds

finalPos = [currentPos(1) + 10, currentPos(2) + 10 , currentPos(3)];
[currentPos, Ts, qz] = moveRobotArm(robot, qz, finalPos, steps, rotation);
pause(2); % Pauses execution for 2 seconds


%% 2.1 - ESPACIO ALCANZABLE

% Definición de los límites (puedes ajustar según sea necesario)
limits = [
    -pi, pi;                                    % q1: Rotación completa de la base
    -pi/2 - offset_codo, pi/2 - offset_codo;    % q2: Ajustado por el offset del codo
    -pi/2 + offset_codo, pi/2 + offset_codo;    % q3: Ajustado por el offset del codo
    -pi/2, pi/2;                                % q4: Rotación de ±90°
    -pi, pi                                     % q5: Rotación completa del efector final
];

degree_step = [30, 20, 20, 20, 180];
qz = [0, -offset_codo, offset_codo, pi/2, 0];

plotSpace(limits, robot, degree_step, qz);

